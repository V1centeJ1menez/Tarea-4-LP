
Resumen de la "Programación Funcional y Scheme":

1. Introducción a la Programación Funcional:
   - Paradigma diferente a los imperativos, basado en funciones matemáticas (notación lambda de Church).
   - No se utilizan variables ni asignaciones. La repetición se logra mediante recursión.
   - LISP fue el primer lenguaje funcional, derivando lenguajes como Scheme, Common LISP, ML y Haskell.
   - Las funciones son puras, es decir, siempre devuelven los mismos resultados para los mismos parámetros y no tienen efectos colaterales.

2. Introducción a Scheme:
   - Dialecto de LISP desarrollado en el MIT en los años 70.
   - Pequeño y con sintaxis simple. Las funciones son entidades de primera clase.
   - El ciclo REPL (leer, evaluar, imprimir) es fundamental.
   - Tiene estructuras inmutables y utiliza recolección automática de basura.

3. Condicionales:
   - Uso del condicional `if` y `cond` para evaluar expresiones dependiendo de condiciones.
   - Expresiones lógicas (and, or, not) y relacionales (>, <, =).

4. Recursión:
   - Tipos de recursión: directa, indirecta, lineal, múltiple, de cabeza, de cola.
   - La recursión de cola es óptima y evita overflow de pila, siendo manejada por Scheme como un "salto" en el código.

5. Asignación:
   - `let` y `define` crean variables locales y globales, respectivamente.
   - `set!` permite modificar el valor de una variable ya existente.

6. Ligado de Variables:
   - Ligado local con `let`, `let*` y `letrec`, siendo `letrec` útil para definir procedimientos recursivos.
   - `lambda` permite definir funciones anónimas.

7. Otras Operaciones en Scheme:
   - Funciones de orden superior como `apply`, `map`, y `filter` para manipular listas y secuencias.
   - Evaluación perezosa con `delay` y `force`.

Formulario Práctico en Scheme:

Definición de funciones:
(define (nombre_funcion argumentos)
  cuerpo_de_la_funcion)

Expresiones condicionales:
(if test
    consecuencia
    alternativa)

(cond
  (test1 consecuencia1)
  (test2 consecuencia2)
  (else alternativa))

Recursión:
(define (factorial n)
  (if (= n 0)
      1
      (* n (factorial (- n 1)))))

Asignación de valores:
(let ((x valor_x) (y valor_y))
  expresion)

Listas:
(define lista '(a b c d))  ; Definir una lista
(car lista)                ; Primer elemento de la lista
(cdr lista)                ; Resto de la lista

Funciones de orden superior:
(map procedimiento lista1 lista2)
(filter predicado lista)
(apply procedimiento lista)

Evaluación perezosa:
(define promesa (delay (+ 3 4)))
(force promesa)  ; Evaluar la promesa
